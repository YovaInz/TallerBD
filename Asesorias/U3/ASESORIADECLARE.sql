


--------------------------------
-- PROCEDIMIENTOS ALMACENADOS --
--                            --
--------------------------------

-- PROGRAMACION CON TRANSACT-SQL

-- DECLARACION DE VARIABLES
-- DECLARE @NOM_VARIABLE TIPO_DATO

-- TIPO_DATO: SON TIPOS DE DATOS VALIDO EN SQL SERVER:
BIT, INT, NUMERIC, CHAR, VARCHAR, DATETIME, ETC.

-- ASIGNACION DE VARIABLE
SELECT @NOM_VARIABLE = VALOR;
SET @NOM_VARIABLE = VALOR;

-- LOS VALORES DE CADENA DE CARACTERES Y FECHA LLEVAN COMILLAS PARA SU ASIGNACION
SELECT @NACIMIENTO = '01-01-2007';
SELECT @NOMBRE = 'JUAN PEREZ';

-- LOS VALORES NUMERICOS SE ASIGNAN DE MANERA NORMAL
SELECT @X = 12.1

-- IMPRESION 
PRINT @NOM_VARIABLE
SELECT @NOM_VARIABLE

-- EJEMPLO
DECLARE @TOTAL NUMERIC(7,3) ---> -+9999.999
SELECT @TOTAL
SELECT @TOTAL = 9999.999
SELECT @TOTAL
SELECT @TOTAL = COUNT(*) FROM EMPLOYEES
SELECT @TOTAL
GO
-- EJEMPLO
DECLARE @TOTAL NUMERIC(12,2), @MIN INT 
SELECT @TOTAL = COUNT(*), @MIN = MIN(EMPLOYEEID)FROM EMPLOYEES
SELECT @TOTAL, @MIN

--- EJEMPLO: NO SE DEBE ASIGNAR UNA LISTA DE RESULTADOS A UNA VARIABLE
DECLARE @TOTAL NUMERIC(12,2)
SELECT @TOTAL = EMPLOYEEID FROM EMPLOYEES ORDER BY EMPLOYEEID DESC
SELECT @TOTAL

-- VARIABLES DE SISTEMA 
-- SON VARIABLES QUE UTLIZA SQL SERVER PARA ADMINISTRAR RECURSOS. NO SE PUEDEN MODIFICAR,
-- SOLAMENTE LEER O IMPRIMIR
SELECT @@VERSION --: CONTIENE LA VERSION DE SQL SERVER
SELECT @@FETCH_STATUS --: SE UTILIZA EN CURSORES, INDICA LA POSICION DEL CURSOR
SELECT @@ERROR --: ADMINISTRA EL TIPO DE ERROR QUE HA OCURRIDO.
SELECT @@CONNECTIONS-- : INDICA EL NUMERO DE CONEXIONES ACTIVAS.
SELECT @@ROWCOUNT --: INDICA LOS RENGLONES AFECTADOS POR UNA INSTRUCCION INSERT, UPDATE O DELETE
SELECT @@IDENTITY --: INDICA EL ULTIMO VALOR OBTENIDO EN UNA TABLA CON LA PROPIEDAD IDENITTY



/* SENTENCIA IF: SE UTILIZA PARA EJECUTAR UNA CONDICION
IF(CONDICION)
BEGIN
	SENTENCIA1
	SENTENCIA2
END
BEGIN
	SENTENCIA3
	SENTENCIA4
END
*/

-- IMPRIMIR EL PRECIO DEL PRODUCTO MAS CARO Y ESPECIFICAR SI ES MAYOR A 30 PESOS O NO
-- PRECIO MAYOR:
DECLARE @PRECIO NUMERIC(12,2)
SELECT @PRECIO = MAX(UNITPRICE) FROM PRODUCTS

IF @PRECIO > 30
	PRINT 'EL PRECIO MAXIMO ES MAYOR A 30 = ' + CONVERT(VARCHAR(10), @PRECIO)
ELSE
	PRINT 'EL PRECIO MAXIMO ES MENOR A 30 = ' + CONVERT(vARCHAR(10), @PRECIO)

	-- PRECIO MENOR:
DECLARE @PRECIO NUMERIC(12,2)
SELECT @PRECIO = MIN(UNITPRICE) FROM PRODUCTS

IF @PRECIO > 30
	PRINT 'EL PRECIO MAXIMO ES MAYOR A 30 = ' + CONVERT(VARCHAR(10), @PRECIO)
ELSE
	PRINT 'EL PRECIO MAXIMO ES MENOR A 30 = ' + CONVERT(vARCHAR(10), @PRECIO)

--INSTRUCCION IF EXISTS (CONSULTA): SE UTILIZA PARA CONSULTAR Y VERIFICAR LA EXISTENCIA DE REGISTROS.
-- VERIFICAR SI EXISTE EL PRODUCTO 1000
IF EXISTS(SELECT*FROM PRODUCTS WHERE PRODUCTID = 1000)
	PRINT 'SI EXISTE EL PRODUCTO 1000'
ELSE
	PRINT 'NO EXISTE EL PRODUCTO 1000'

-- VERIFICAR SI EXISTE EL PRODUCTO 20
IF EXISTS(SELECT*FROM PRODUCTS WHERE PRODUCTID = 20)
	PRINT 'SI EXISTE EL PRODUCTO 20'
ELSE
	PRINT 'NO EXISTE EL PRODUCTO 20'

-- SENTENCIA WHILE
WHILE(CONDICION)
BEGIN
	SENTENCIA1
	SENTENCIA2
END

SELECT PRODUCTID FROM PRODUCTS ORDER BY 1


-- EJEMPLO:
-- RECORRER LA TABLA PRODUCTOS E IMPRIMIR LA CLAVE DE TODOS LOS PRODUCTOS
DECLARE @MIN INT
SELECT @MIN = MIN(PRODUCTID) FROM PRODUCTS

WHILE @MIN IS NOT NULL
BEGIN 
	PRINT @MIN

	SELECT @MIN = MIN(PRODUCTID) FROM PRODUCTS WHERE PRODUCTID > @MIN
END
PRINT 'FIN DEL CICLO'


-- EJEMPLO MAYOR A MENOR, LA CLAVE DE EMPLEADO Y CLAVE DE SU JEFE INMEDIATO
DECLARE @EMP INT, @JEFE INT
SELECT @EMP = MAX(EMPLOYEEID) FROM Employees
WHILE @EMP IS NOT NULL
BEGIN
	SELECT @JEFE = ReportsTo FROM EMPLOYEES WHERE EMPLOYEEID = @EMP

	PRINT STR(@EMP) + ', ' + STR(ISNULL(@JEFE, ''))

	SELECT @EMP = MAX(EMPLOYEEID) FROM EMPLOYEES WHERE EMPLOYEEID < @EMP
END
PRINT 'FIN DEL CICLO'


-- CAPTURAR UNA FECHA, Y MEDIANTE UN PROCESO LLENAR UNA TABLA
-- TEMPORAL CON LAS SUS ANIVERSARIOS Y EL DIA DE LA SEMANA QUE SE FESTEJO.
-- SPANIVERSARIODIASEMANA.JPG
DECLARE @FECHA DATETIME, @DIA VARCHAR(50)

CREATE TABLE #T(FECHA DATETIME, DIA VARCHAR(50))

SELECT @FECHA = '1-1-2000' 

WHILE @FECHA < GETDATE()
BEGIN 
	SELECT @DIA = DATENAME(DW, @FECHA)
	INSERT #T VALUES(@FECHA, @DIA)
	
	SELECT @FECHA = DATEADD(YY, 1, @FECHA)
END

SELECT*FROM #T
DROP TABLE #T

-- PROCESO QUE RECIBA LA FECHA EN QUE INICIO A TRABAJAR UN EMPLEADO Y CALCULE
-- LOS DIAS TRABAJADOS RESTAR SOLO LOS SABADOS Y DOMINGOS

DECLARE @FECHA DATETIME, @CONTA INT = 0, @DIA INT

SELECT @FECHA = '1-1-2000'

WHILE @FECHA <= GETDATE()
BEGIN
	SELECT @DIA = DATEPART(DW, @FECHA)
	IF @DIA IN (2,3,4,5,6)
	SELECT @CONTA = @CONTA + 1

	SELECT @FECHA = DATEADD(DD, 1, @FECHA)
END
SELECT @CONTA

-- PROCESO PARA ENCONTRAR LOS DIAS TRABAJADOS POR EMPLEADO DESCONTANDO
-- LOS SABADOS Y DOMINGOS
DECLARE @CLAVE INT, @FECHA DATETIME, @DIA INT, @CONTA INT
CREATE TABLE #TABLA(EMP INT, DIAS INT)
SELECT @CLAVE = MIN(EMPLOYEEID) FROM EMPLOYEES
WHILE @CLAVE IS NOT NULL
BEGIN 
	SELECT @FECHA = HIREDATE FROM EMPLOYEES WHERE EmployeeID = @CLAVE
	SELECT @CONTA = 0

	WHILE @FECHA <= GETDATE()
	BEGIN
		SELECT @DIA = DATEPART(DW, @FECHA)
		IF @DIA IN (2,3,4,5,6)
			SELECT @CONTA = @CONTA + 1

		SELECT @FECHA = DATEADD(DD, 1, @FECHA)
	END
	INSERT #TABLA VALUES(@CLAVE, @CONTA)

	SELECT @CLAVE = MIN(EMPLOYEEID) FROM EMPLOYEES WHERE EMPLOYEEID > @CLAVE
END

SELECT E.FirstName + ' ' + E.LastName, TRABAJADOS = T.DIAS, VIEJO = DATEDIFF(DD, E.HireDate, GETDATE())
FROM #TABLA T
INNER JOIN EMPLOYEES E ON E.EmployeeID = T.EMP


-- PROPORCIONAR UNA FECHA DE NACIMIENTO Y CALCULAR LA EDAD EXACTA:
DECLARE @EDAD INT, @FECHA DATETIME

SELECT @FECHA = '12-17-2003'
SELECT @EDAD = DATEDIFF(YY, @FECHA, GETDATE())
SELECT @FECHA = DATEADD(YY, @EDAD, @FECHA)

IF @FECHA > GETDATE()
	SELECT @EDAD = @EDAD - 1

SELECT EDAD = @EDAD


-- TABLA CON LA CLAVE DEL EMPLEADO Y LA EDAD EXACTA DE LOS EMPLEADOS (NO BIEN DEFINIDO)
---INICIO DE ASESORIA 12 DE ABRIL DEL 2024--------

CREATE PROC SP_EDADES AS 
BEGIN
DECLARE @EMP INT, @FECHA DATETIME, @EDAD INT
CREATE TABLE #TABLA(EMP INT, EDAD INT)

SELECT @EMP = MIN(EMPLOYEEID) FROM EMPLOYEES
WHILE @EMP IS NOT NULL
BEGIN
	SELECT @FECHA = BIRTHDATE FROM EMPLOYEES WHERE EMPLOYEEID = @EMP
	SELECT @EDAD = DATEDIFF(YY, @FECHA, GETDATE())
	SELECT @FECHA = DATEADD(YY, @EDAD, @FECHA)

	IF @FECHA > GETDATE()
		SELECT @EDAD = @EDAD - 1

	INSERT #TABLA VALUES (@EMP, @EDAD)

	SELECT @EMP = MIN(EMPLOYEEID) FROM EMPLOYEES WHERE EMPLOYEEID > @EMP
END
END
PRINT 'FIN DEL CICLO'

SELECT E.FIRSTNAME + ' ' + E.LASTNAME, E.BirthDate, DATDIFF = DATEDIFF(YY, E.BIRTHDATE, GETDATE()), T.EDAD
FROM #TABLA T
INNER JOIN EMPLOYEES E ON E.EMPLOYEEID = T.EMP

DROP TABLE #TABLA
 
--  CREAR PROCEDIMIENTO
CREATE PROC SP_EDADES

-- EJECUTAR PROCEDIMIENTO
EXEC SP_EDADES

-- OBTENER CREACION DE ALGO
SP_HELPTEXT SP_EDADES

